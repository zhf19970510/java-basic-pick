# JVM类加在机制

当我们启动某个类的main函数启动程序时，首先需要通过类加载器把主类加载到JVM。

类被加载到方法区中后主要包含 **运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用**等信息。

**类加载器的引用**：这个类到类加载器实例的引用。

**对应class实例的引用**：类加载器在加载信息放到方法区中后，会创建一个对应的Class 类型的对象实例放到堆（Heap）中，作为开发人员访问方法区中类定义的入口和切入点。



注意，主类在运行过程中如果使用到其它类，会逐步加载这些类。

jar包或war包里的类不是一次性全部加载的，是使用到时才加载的。



## 类加载器和双亲委派机制

上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器：

引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar，charsets.jar等。

扩展类加载器：负责加载支撑JVM运行的lib目录下ext扩展目录中的JAR类包。

应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类。

自定义加载器：负责加载用户自定义路径下的类包。



### 双亲委派机制

![image-20220305115745366](https://gitee.com/zhf19970510/image-server/raw/master/img/20220305115748.png)

#### 为什么要设计双亲委派机制？

沙箱安全机制：自己写的java.lang.String.class 类不会被加载，这样便可以防止核心API库被随意篡改；

避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性；

### 全盘负责委托机制

“全盘负责”是指当一个ClassLoader装载一个类时，除非显示的使用另一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入。



### 自定义类加载器 

![image-20220305165237688](https://gitee.com/zhf19970510/image-server/raw/master/img/20220305165240.png)