### java面试题记录

1. #### 说一下JVM的主要组成部分及其作用？

JVM包含两个子系统和两个组件，两个子系统为Classs loader(类装载)、Execution engine(执行引擎)；两个组件为 Runtime data area(运行时数据区)、Native Interface(本地接口).
  Class loader(类装载):根据给定的全限定名类名来装载class文件到Runtime data area中的method area。
  Execution engine(执行引擎)：执行classes中的指令。
  Native Interface(本地接口)：与 native libraries交互，是其它编程语言交互的接口。
  Runtime data area(运行时数据区域)：这就是我们常说的 JVM 的内存。
作用：首先通过编译器吧Java代码转换为字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层操作系统执行，因此需要特定的命令解析器执行引擎（Execution engine），将字节码翻译成底层系统指令，再交由CPU去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。

2. #### mysql索引设计的原则有哪些？

   1.适合索引的列是出现在where子句中的列，或者连接子句中指定的列；

   2.基数较小的类，索引效果较差，没有必要在此列建立索引；

   3.使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间；

   4.不要过度索引，索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。索引只保持需要的索引有利于查询即可。

3. #### 并发编程三要素是什么？在Java程序中怎么保证多线程的运行安全？

   并发编程的三要素（线程安全性问题体现在）：

   原子性：原子，即一个不可再分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。

   可见性：一个线程对共享变量的修改，另一个线程能够立刻看到。（synchronized, volatile）

   有序性：程序执行的顺序按照代码的先后顺序。（处理器可能会对指令进行重排序）

   出现线程安全问题的原因：

   - 线程切换带来的原子性问题
   - 缓存导致的可见性问题
   - 编程优化带来的有序性问题

   解决办法：

   JDK Atomic开头的原子类、sychroneizd、LOCK，可以解决原子性问题

   synchronized、volatile、LOCK，可以解决可见性问题

   Happens-Before 规则可以解决有序性问题

4. #### 创建索引的原则

1）最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配，比如 a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2）较频繁作为查询条件的字段才去创建索引。

3）更新频繁字段不适合创建索引。

4）不能有效区分数据的列不适合做为索引列（如性别，男、女、未知，区分度太低）。

5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a, b)的索引，那么只需要修改原来的索引即可。

6）定义有外键的数据列一定要建立索引。

7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。

8）对于定义为text、image和bit的数据类型的列不要建立索引。

5. #### 请解释 Spring Bean 的生命周期？

Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。
Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。

1. 初始化之后调用的回调方法。
2. 销毁之前调用的回调方法

Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：

InitializingBean 和 DisposableBean 回调接口；
针对特殊行为的其他 Aware 接口；
Bean 配置文件中的 Custom init()方法和 destroy()方法；
@PostConstruct 和@PreDestroy 注解方式。

6. #### zookeeper 是如何保证事务的顺序一致性的？

   zookeeper 采用了递增的事务 Id 来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时期; 纪元; 世; 新时代）用来标识 leader 是否发生改变，如果有新的 leader 产生出来，epoch 会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。

7. #### MQ中，有哪些情况消息可能会成为死信？RabbitMQ中的延迟队列是怎么实现的？

   消息成为死信的三种情况：
   1. 队列消息长度到达限制；
   2. 消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false；
   3. 原队列存在消息过期设置，消息到达超时时间未被消费；
     RabbitMQ通过TTL+死信队列 组合实现延迟队列。

8. #### MQ中如何防止消息重复消费、以及如何处理消息积压？

   首先需要知道幂等性的概念了，幂等性指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。在MQ中指，消费多条相同的消息，得到与消费该消息一次相同的结果。我们可以使用乐观锁机制达到消息幂等性保障，减少消息重复消费的情况。
   然后就是要知道消息积压产生的原因有哪些：
   1. 消费者宕机积压；
   2. 消费者消费能力不足积压；
   3. 发送者发流量太大；
   解决消息积压的方案：

   1. 上线更多的消费者,进行正常消费；
   2. 上线专门的队列消费服务；
   3. 将消息先批量取出来,记录数据库,再慢慢处理；

9. #### Redis如何做内存优化？

